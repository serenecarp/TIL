# JavaScript

- 프로토타입 기반 객체 생성을 지원하는 동적 스크립트 언어
    - 코드의 중복 해결
- 웹 브라우저에서 주로 사용, Node.js를 이용하여 콘솔 환경에서 사용
- 웹 브라우저의 UI를 제어하기 위해 만들어진 프로그래밍 언어
- 자바와 기본 구문이 비슷하다. (C언어의 기본 구문을 바탕)
- 브랜든 아이크 개발(1995)
    - Mocha → LiveScript → JavaScript

## 기본 문법

- `<script></script>` 태그를 사용
- 문서 내 위치 제약 x

### 외부 스크립트 참조하기

- .js 확장자를 가진 파일 생성
- html 문서에서 `<script src="외부파일의 위치"></script>`

### 주석

- `//` : 한 줄 주석
- `/* */` : 여러 줄 주석

## 변수

- `var` , `let` (변수), `const` (상수) 키워드
- 동적 타입: 대입되는 값에 따라 용도가 변경되는 방식

### var

- 재선언 가능, 재할당 가능
- ES6 이전에 변수 선언 시 사용
- 호이스팅(Hoisting) 특성이 있음
    - 런타임: 소스코드가 한 줄 한 줄 순차적으로 실행되는 시점
    - 자바스크립트는 바로 런타임으로 들어가지 않고, 사전 준비단계(소스코드 평가)를 거친다.
    - var들을 먼저 메모리에 올려 놓고 선언 → undefined로 초기화 후 런타임!
- 함수 스코프
    - 전역변수로 쓰이거나, 함수의 지역변수로 쓰임
    - cf) `let`, `const` 블록스코프: 자기가 선언된 블록 안에서만 ok
    

### let

- 재선언 불가, 재할당 가능
- 블록스코프

### const

- 재선언 불가, 재할당 불가
- 블록스코프
- 대문자 SNAKE_CASE 사용
- 선언시 값을 할당해야 함
- 상수로 사용

### undefined

- 변수에 값이 대입되지 않은 상태

## 데이터 타입(Data Type)

- 기본 데이터 타입 (Primitive Type)
    - String, Number, Boolean, null, undefined
- 객체 타입 (Reference Type)
    - Object - function, array 등
- es6에서 추가된 타입: Symbol(변경 불가능한 기본 타입)
    - {key : value}

### typeof - 변수의 자료형 검사

- `typeof 데이터`
- `typeof (데이터)`
- typeof의 결과는 문자열

- null의 데이터 타입은 null이 아닌 object (설계 실수 ㅋㅋ)
- function은 기능을 가진 객체
- symbol

### 동적 데이터 타입

- 다양한 값의 대입이 가능

### 숫자형 (Number)

- 정수와 실수로 나누어 구분하지 않음 (부동소수점 형식)
- 일반적인 숫자 외 특수 숫자 포함 (Infinity, NaN …)
- e를 활용하여 거듭제곱 표현 가능

### 문자열 (String)

- `" "`
- `' '`
- 백틱으로 감싸기 →

### 문자열 연산

### 자바스크립트 false

- 아래 다섯가지 값은 false로 인식, 나머지 값은 true로 인식
    - `null`
    - `undefined`
    - `0`
    - `‘’` (빈 문자열)
    - `NaN`
    

## 연산자 (Operator)

### 일치 연산자

- 값과 타입이 일치하는지 체크
- `===`, `!==`
- 

## 제어문 (Java와 유사)

## 배열 (Array)

- 배열 생성: `[]` 또는 `Array()`
- 배열의 크기는 동적으로 변경
- 크기가 지정되지 않은 경우에도 데이터 입력 가능
- 배열의 길이는 가장 큰 인덱스 +1
- 여러 가지 데이터 타입을 하나의 배열에 입력 가능
- `push` 함수를 이용해 데이터 추가 가능

## 객체 (Object)

- 문자열로 이름을 붙인 값들의 집합체 (Key : Value)
- 객체에 저장하는 값을 프로퍼티(Property)라고 한다.
- 객체는 prototype이라는 특별한 프로퍼티를 가지고 있다.

### 객체 만들기

- 객체 리터럴 이용: `{}`
- Object 생성자 이용: `new Object()`
- 생성자 함수 이용 (= 일반 함수 (대문자)) ⇒ 재사용하기 편함!

```jsx
let member1 = {};
let member2 = new Object();
function Member() {}
let member3 = new Member();
```

### 객체 생성시 프로퍼티 추가

```jsx
let member1 = {id: "shy", email: "ssafy@a.com"}
function Member(id, email) {
	this.id = id;
	this.email = email
}
let member2 = new Member("shy", "ssafy@a.com");
```

### 객체 프로퍼티

- `.` (dot) 또는 `[]` 를 이용하여 프로퍼티의 조회 및 변경을 처리한다.

### 객체 프로퍼티 - 추가/수정/삭제

- `delete`

객체 변수에는 ***주소가 저장***되어 공유 가능

### this

- 함수 안에서의 this는 함수(객체의 멤버로서의 함수)를 호출한 객체

```jsx
var m1 = {name: "홍길동"};
var m2 = {name: "배수지"};
function msg() {
	console.log(this);
	console.log(this.name + "님이 입장");
}
m1.msg = msg;
m2.msg = msg;
m1.msg(); // 홍길동님이 입장
m2.msg(); // 배수지님이 입장
```

## 함수 (function)

### 함수 특징

- 자바스크립트에서 함수는 객체 타입으로 값처럼 사용이 가능하다.
- 함수를 변수에 대입하거나 매개변수로 넘길 수 있다.
- 배열의 요소에 넣거나 객체의 프로퍼티로 설정이 가능하다.
- 매개변수의 개수가 일치하지 않아도 호출이 가능하다.
- JavaScript의 함수는 일급 객체(First-class citizen)에 해당
    - 변수에 할당 가능
    - 함수의 매개변수로 전달 가능
    - 함수의 반환값으로 사용가능
    

### 함수 만들기

- 함수 선언식
    
    ```jsx
    function 함수명() { 함수 내용 }
    ```
    
- 함수 표현식
    
    ```jsx
    let 함수명 = function() { 함수 내용 }
    ```
    

### 함수 선언식 (function declaration)

- 함수의 이름과 함께 정의하는 방식
- 함수의 이름
- 매개 변수
- 내용
- 호이스팅 됨

### 함수 표현식 (function expression)

- 익명함수로 정의 가능
- 매개 변수
- 내용

### 선언식 vs. 표현식

- 선언식 함수는 호이스팅의 영향을 받아 함수 선언 이전에 호출이 가능하다
- 표현식 함수는 선언 이전에 호출이 불가능하다.

### 함수의 리턴

- 함수의 실행 결과로 함수를 반환할 수 있다.
- 함수가 특별한 값을 리턴하지 않은 경우 undefined가 반환된다.

### 함수의 호출

- 정의된 함수를 호출시 함수를 값으로 넘길 수 있다.

### 함수의 매개변수

- 함수는 호출시 매개변수의 영향을 받지 않는다.
- arguments라는 함수 내부의 프로퍼티를 이용하여 매개변수의 처리가 가능하다.
- 자바스크립트의 함수는 오버로딩 개념을 지원하지 않는다.
- 기본 인자(default arguments)를 사용할 수 있다.

### 화살표 함수 (Arrow Function)

- ES6에서 추가된 개념
- 함수를 심플하게 정의할 수 있도록 해준다.
- 형태
    - (매개변수) ⇒ { 명령어 }
- 작성 순서
    1. function 키워드 삭제
    2. () 안에 함수가 사용할 파라미터 이름 작성
    3. 화살표 (⇒) 를 붙인다.
    4. {} 를 작성하고 블록 안에 함수가 실행할 코드 작성
- 매개변수가 하나일 경우 () 생략 가능
- 실행문장이 하나일 경우 {} 생략 가능
    - 실행되는 하나의 문장이 return문일 경우 return 키워드를 생략해야 함!